# 도커 입문

# 1\. 환경 구성

**Winpty 설정**

Git Bash에서 Container Shell로 접근하려면 docker 앞에 winpty 명령어를 추가해야 함

```
echo "alias docker='winpty docker'" >> ~/.bashrc
```

  

**WSL(Windows Subsystem for Linux)**

Docker Desktop은 실제 윈도우 환경에서 컨테이너를 실행시키는 게 아닌 WSL이라는 소프트웨어를 통해 리눅스 가상환경에서 실행시킴

  

## 실행 중인 컨테이너를 모두 삭제하는 방법

```
docker rm -f $(docker ps -aq) # in MacOS
docker ps -aq | ForEach-Object {docker rm -f $_} # PowerShell in Windows
```

  

* * *

  

# 2\. 가상화 기술

## 2-1. 도커? 컨테이너?

도커: 컨테이너를 관리하기 위해 만들어진 소프트웨어

컨테이너: 큰 서버를 나누어서 효율적으로 사용하기 위한 가상화 기술

  

도커와 컨테이너를 이해하기 위해 서버와 가상화기술이 무엇이고 왜 사용해야 하는지 알아야 함

대표 가상화 기술: 하이퍼바이저 vs 컨테이너

  

## 2-2. 애플리케이션 서버

### 서버

(서버를 구성하는) 하드웨어 + 소프트웨어

- 일반적인 의미: 하드웨어에서 실행 중인 소프트웨어
- Serve: (무언가를) 제공해주다 → Server: 제공하는 주체
- 요청이 오면 처리하여 응답을 제공

  

**실제 기업에서 운영하는 서버**

- 파일서버: 파일 공유
- DB서버: 데이터 관리
- 웹서버: 정적 웹페이지 제공
- 웹 애플리케이션서버(WAS): 프로그래밍 언어로 개발된 백엔드 애플리케이션 실행

  

### 서버 운영 방식

1. 베어메탈 방식(Baremetal): 서버를 구입하고 그 위에 OS를 설치하고 여러 개의 소프트웨어를 실행

    - 기업에서 사용하기에는 비효율적인 방식

2. 하이퍼바이저 방식(Hypervisor)
3. 컨테이너 방식(Container)

  

엔터프라이즈 환경에서는 아주 많은 양의 서버를 운영해야 함

2, 3번이 가상화 기술을 활용한 서버 운영 방식

  

### 왜 개발자가 도커를 학습해야 하는가?

- 현대 IT 산업에서 인프라 운영은 **아주 높은 수준의 추상화** 기술을 제공
    - “아주 높은 수준의 추상화” → 다루기 더 쉬워짐
- 개발자와 운영자의 경계를 허무는 DevOps 문화 확산
- 소스 코드로 인프라를 운영하는 IaC 기술도 현업에서 많이 활용됨
- 도커를 활용하면 개발자가 인프라의 설정 영역까지 기술 스택 확장 가능
- MSA구조에서 개발자가 소스뿐만 아니라 애플리케이션 실행 환경까지 중요하게 고려해야 할 부분이 됨

  

## 2-3. 가상화 기술

가상: 실제로 존재하지 않지만 실제로 존재하는 것처럼 느껴지는 것

가상 → 가상화 기술: 실제로 존재하는 컴퓨터가 아니지만 마치 존재하는 것처럼 만들어주는 기술

- 하나의 컴퓨터에서 여러 개의 컴퓨터를 실행시키는 기술
- 기술적 정의: 물리적인 컴퓨팅 환경 내부에서 논리적인 컴퓨팅 환경을 만들 수 있는 기술

  

**컴퓨터 여러 대를 사용하지 않고 복잡하게 가상화 기술을 사용하는 이유**

- 하드웨어의 사양은 높아지고 있는 반면, 소프트웨어의 크기는 상대적으로 낮아지고 있음
- 기업 입장에서 여러 면에서 훨씬 경제적임
    - 사양이 낮은 컴퓨터 하나를 사용하는 것보다 높은 성능 하나를 사용
    - 가격, 설치 공간, 설치 인력, 서버 운영, 전력 소모, 하드웨어 사이즈나 배선 등

  

### 하이퍼바이저

하이퍼바이저: 컴퓨터에 설치되는 프로그램

- OS에 하이퍼바이저를 실행해서 가상환경 관리

호스트 OS: 물리적인 서버에 실행되는 OS

- 물리적인 하드웨어와 직접 연결되어 있음
- 하이버바이저는 가상환경을 생성하고 호스트 OS 자원을 격리해서 새로운 OS 실행 → 게스트 OS

게스트 OS: 호스트 OS의 리소스를 나눈 논리적인 공간

- 가상머신이라고 부름
- 웹서버, WAS, DB 같은 서버 프로그램을 프로세스로 실행해서 운영

  

### 하이퍼바이저 서버 운영 방식

1. 서버에 호스트 OS 설치
2. 가상화 기술을 사용하기 위해 하이퍼바이저 설치
3. 가상머신을 만들어 게스트 OS 실행
4. 게스트 OS에서 실제 실행을 원하는 프로세스 운영

  

### 하이퍼바이저 역할

- 이 기종 커널 간 요청 전달
- 가상머신 리소스 할당량 관리

  

**하이퍼바이저가 리소스를 관리하는 방법**

호스트 OS가 커널에서 제공하는 시스템 콜을 통해 서버 하드웨어의 물리적인 리소스를 사용할 수 있음

게스트 OS가 이 리소스를 사용하려면?

1. 호스트 OS에서 여러 게스트 OS를 실행
2. 게스트 OS의 커널은 실제로 물리적인 하드웨어가 없기 때문에 호스트 OS의 커널로 리소스 사용 요청
3. 호스트 OS와 게스트 OS의 종류가 다르면 호스트 OS는 게스트 OS의 요청을 처리할 수 없음
4. 하이퍼바이저가 이 기종 커널 간 통역을 담당

  

## 2-4. 컨테이너 가상화 기술

“가볍고 빠르다”

###   

### 하이퍼바이저 vs 컨테이너 가상화

**컨테이너 가상화 기술의 시작, LXC**

- 컨테이너 가상화는 리눅스 커널이 제공하는 LXC(LinuX Containers)라는 자체 격리 기술에서 출발
- LXC 기술을 사용하면 하이퍼바이저를 사용하지 않고도 커널의 자체 기능만 사용해서 격리된 공간을 만들 수 있음

  

**LXC(LinuX Containers)**

커널의 네임스페이스와 CGroups(Control Groups) 라는 기능을 활용함

- 네임스페이스: 프로세스와 하드드라이브, 네트워크, 사용자, 호스트네임처럼 리소스를 나누는 기준의 역할
- CGroups: 프로세스가 사용하는 메모리와 CPU, 하드디스크, 네트워크 Bandwidth처럼 리소스의 사용량을 배분하는 기술

  

LXC 기술을 사용해서 만들어진 각각의 격리된 공간을 컨테이너라고 부름

  

### 컨테이너 가상화 방식은 가볍고 빠르다

컨테이너 가상화는 커널의 격리 기능을 활용하기 때문에 모든 컨테이너는 호스트 OS의 커널을 공유해서 사용

  

**오버헤드가 적다**

하이퍼바이저 방식: 각각의 시스템 콜들이 하이퍼바이저의 통역을 거침

- 요청이 거쳐가는 단계가 늘어남
- 즉, 오버헤드가 큼

컨테이너 가상화 방식: 호스트OS의 커널을 그대로 사용함

- 요청 중간단계가 없음
- 오버헤드가 상대적으로 적음
- 즉, 하드웨어 리소스 사용 요청이 더 효율적으로 이루어짐

  

**부팅 속도가 빠르다**

하이퍼바이저 방식

- 커널이 독립적으로 존재
- 즉, 커널을 실행함에 있어서 시간이 더 필요

컨테이너 가상화

- 하나의 호스트 OS 커널을 공유
- 커널을 실행하는 시간이 필요하지 않음
- 즉, 부팅 속도 빠름

**모던 애플리케이션의 중요 요구사항**  

- 적은 오버헤드
- 빠른 부팅

  

### 하지만, 항상 정답은 아니다

1. 하이퍼바이저 가상화는 커널을 독립적으로 가짐으로써 보안면에서는 더 뛰어남
2. 컨테이너 가상화는 호스트 OS의 커널을 공유하기 때문에 다른 종류의 OS는 실행할 수 없다는 점이 상대적인 단점임

  

## 2-5. 도커

커널이 자체적으로 제공하는 가상화 기술은 사용자가 직접 컨트롤하기 어려움

반면, 커널의 컨테이너 가상화 기술은 직접 컨트롤할 수 있어 도커를 통해 컨테이너를 만들고 운영할 수 있음

  

하이퍼바이저 방식에서 격리된 공간을 만드는 주체 → 하이퍼바이저라는 소프트웨어

컨테이너 가상화에서 실제 격리를 수행하는 주체 → 커널 그 자체

도커는 이 커널의 가상화 기술을 활용할 수 있게 도와주는 보조 도구임

  

도커: 컨테이너 가상화 기술을 사용하기 위한 도구

- 2013년에 최초로 공개된 오픈소스 소프트웨어

  

### 컨테이너 플랫폼

도커와 같은 컨테이너 가상화 도구

- 컨테이너 엔진: 사용자의 요청을 받아서 컨테이너 관리
- 컨테이너 런타임: 직접 커널과 통신하며 실제로 격리된 공간을 만드는 역할 수행
    - 도커는 runc라는 기본 컨테이너 런타임 사용
    - OCI에서 규정한 CRI(Container Runtime Interface) 표준을 구현했기 때문에 무조건 runc를 사용해야 하는 건 아님

  

컨테이너 가상화 기술을 사용할 때 어떤 컨테이너 플랫폼, 컨테이너 런타임을 사용할지는 자유롭게 선택 가능

이 중 도커는 가장 점유율이 높고 가장 빨리 출발했기 때문에 레퍼런스도 많고 문서도 잘 구성되어 있음

  

### 도커 아키텍처

- 클라이언트-서버 모델로 실행됨
    - 클라이언트: 사용자의 명령을 도커 데몬에 전달
    - 도커 데몬(Docker Daemon; 서버): 컨테이너를 관리하는 기능 제공
        - 데몬: 서버에서 지속적으로 실행해야 하는 소프트웨어

- 도커 데몬은 컨테이너 관리 기능을 클라이언트에 제공하기 위해 API 제공
    - 하지만 이 API의 응답을 사용자가 직접 핸들링하기에는 어려움이 있음
- Docker CLI: 도커 API 사용 편의성 제공
    - CLI는 사용자가 입력한 명령어를 API 요청 양식에 맞게 변환하여 전달
    - CLI는 전달받은 응답을 사용자가 보기 편한 테이블 형태로 만들어 화면에 표시

  

## 2-6. 컨테이너 실행

### docker version

Client, Server의 버전 및 상태 확인

  

### docker info

플러그인, 시스템 상세 정보 확인

  

### docker --help

메뉴얼 확인

  

### docker (Management Command) Commad

ex) docker (container) run → docker run

  

### docker run \[실행옵션\] 이미지명

컨테이너 실행

  

### docker rm \[컨테이너명/ID\]

컨테이너 삭제

  

* * *

  

# 3\. 이미지와 컨테이너

이미지? 이미지-컨테이너 관계?

컨테이너의 실행 → 삭제 과정을 테스트해보면서 컨테이너의 라이플사이클을 이해함

  

## 3-1. 이미지

### 서버에서 프로그램은 어떻게 실행하는가?

- 하드웨어가 필요하고 하드웨어에서 실행할 소프트웨어가 필요함
- 소프트웨어는 그 자체만으로 실행할 수 없음
    - 소프트웨어는 다운받은 애플리케이션 파일이나 직접 개발한 애플리케이션일 수 있음
    - 소프트웨어가 하드웨어의 자원을 사용할 수 있도록 필수 기능을 제공해주는 OS가 필요함
    - 소프트웨어는 특정 패키지나 라이브러리 의존
    - 소프트웨어를 실행시키기 위해 런타임 언어가 필요할 수도 있음
        - 자바의 경우 OS에 자바 소프트웨어를 실행시키기 위한 자바 런타임 필요

  

### 서버에서 프로그램을 실행하기 위한 요구사항

- 애플리케이션 실행에 필요한 기본 시스템 파일
- 애플리케이션 실행에 필요한 언어, 라이브러리 및 설정 구성
- 개발자가 개발한 애플리케이션 실행 파일 또는 다운로드 받은 소프트웨어

  

### 도커는 어떻게 서버를 구성하지 않고 한 번에 프로그램을 실행하는가?

도커는 서버에 프로그램을 실행하기 위해 이미지를 사용함

이미지: 특정 시점의 파일시스템(디렉터리)를 저장한 압축 파일

- 제작 단계에서부터 소프트웨어뿐만 아니라 소프트웨어가 실행되기 위해 필요한 모든 요소들을 미리 준비해서 압축함
- 이 이미지 안에는 OS + 구성요소 + 프로그램이 모두 포함되어 있음

  

### 이미지는 백업이나 스냅샷과는 다르다

백업이나 스냅샷으로도 이미지와 비슷하게 기능할 수 있음

하지만, 이미지는 백업이나 스냅샷보다 압축 파일의 사이즈가 훨씬 작음

→ 인터넷을 통해서 저장하고 공유하기가 훨씬 수월함

  

### 정리

도커 사용 목적: 가상화 서버를 빠르고 가볍게 운영하기 위해 사용

이미지: 특정 서버를 실행할 수 있는 상태를 저장한 압축 파일

  

## 3-2. 이미지와 컨테이너

### 프로그램 vs 프로세스

프로그램

- 실행 가능한 소프트웨어
- 디스크 공간 차지

  

프로세스

- 실행 상태의 소프트웨어
- 프로그램 1 :  N 프로세스
- 실행 시 CPU, 메모리 등의 리소스 사용

  

### 이미지 vs 컨테이너

프로그램 - 프로세스 관계와 유사함

  

이미지

- 실행 가능한 소프트웨어 + 실행에 필요한 환경
- 디스크 공간 차지

  

컨테이너

- 실행 상태의 이미지
- 이미지 1 : N 컨테이너
- 컨테이너로 실행 시 CPU, 메모리 등의 리소스 사용
- 컨테이너 간 리소스 격리
- 실행 시 이미지를 복사해 격리된 디스크 공간 생성
    - 컨테이너는 가상화 기술이기 때문에 프로그램-프로세스 관계와 차별되는 요소
- 컨테이너 실행 시 프로세스도 함께 실행

  

### docker image ls (이미지명)

- 로컬 이미지 조회
- 뒤에 이미지명을 명시하면 특정 이미지에 대해 조회 가능

  

### 하나의 이미지로 여러 컨테이너 실행

```bash
docker run -d --name [컨테이너명] 이미지명 # 컨테이너 실행
docker ps # 실행 중인 컨테이너 리스트 조회
docker rm -f # 실행 중인 컨테이너 삭제
```

- `docker run` 
    - `-d` : 백그라운드 실행
    - `--name [컨테이너명]` : 컨테이너의 이름 지정
- ps(**p**roce**s**s), rm(**r**e**m**ove), d(**d**aemon)
- `docker rm` 으로는 실행 중인 컨테이너 삭제 불가 → `-f`  옵션과 함께 실행 중인 컨테이너 삭제 가능

  

## 3-3. 이미지의 메타데이터

메타데이터: 데이터에 대한 데이터

하나의 이미지 = 실제로 압축된 파일 + 이 파일의 정보가 저장되어 있는 메타데이터

  

이미지가 실제로 압축된 데이터라면 메타데이터는 이 이미지에 대한 정보를 기술하는 데이터임

이미지의 이름이 무엇인지, 사이즈가 어떻게 되는지에 대한 정보 저장 관리해야 함

  

### Env와 Cmd

Env: 소프트웨어가 실행 시 참조할 설정 정보

- 키와 값
    - ex) VERSION=1.23.2
- 이 값이 바뀌게 되면 애플리케이션이 다른 방식으로 동작할 수 있음

  

Cmd: 컨테이너 실행 시 프로세스 실행 명령어 지정

- 리눅스에서는 일반적으로 명령어를 통해 프로그램을 실행함
- 이미지를 컨테이너로 실행할 때 Cmd에 있는 명령어를 통해 어떤 프로그램을 실행할 지를 메타데이터에서 결정함
- 여기서 지정한 이미지의 압축 파일과 이미지의 메타데이터를 사용해서 격리된 공간인 컨테이너가 만들어짐
    - 즉, 이미지 메타데이터와 별개로 새롭게 격리된 공간에 컨테이너 메타데이터가 만들어짐
    - 이 이미지가 실행될 때 Cmd의 명령어가 실행됨
    - 컨테이너 메타데이터는 프로세스가 실행될 때 새로운 값으로 덮어씌어질 수 있음

  

### docker inspect

메타데이터 확인

```bash
docker image inspect [이미지명] # 이미지의 세부 정보 조회
docker container inspect [컨테이너명] # 컨테이너의 세부 정보 조회
docker run [이미지명] (실행명령) # 컨테이너 실행 시 메타데이터의 cmd 덮어쓰기
docker run --env KEY=VALUE [이미지명] # 컨테이너 실행 시 메타데이터의 env 덮어쓰기
```

- `docker run [이미지명] (실행명령)` : 실행명령을 수행하는 일회성 컨테이너
    - 해당 컨테이너는 일회성이라 실행 후 바로 종료되기 때문에 ⁠`docker ps` 로 조회 시 확인할 수 없음
        - `docker ps -a` 로 종료된 컨테이너까지 확인할 수 있음
    - 해당 실행명령으로 컨테이너 메타데이터의 Cmd가 덮어쓰기됨
    - 컨테이너 메타데이터는 이미지의 메타데이터의 복사본이기 때문에 컨테이너 메타데이터가 변경됐다고 해서 이미지의 메타데이터가 변경되는 건 아님

  

컨테이너를 실행할 때 메타데이터의 내용을 수정할 수 있고 같은 이미지도 전혀 다른 역할 수행할 수 있는 컨테이너로 만들 수 있음

실행 시 메타데이터를 수정하는 것이 일반적인 방법은 아니며, 보통 이미지를 디버깅할 때 주로 사용함

  

## 3-4. 컨테이너의 라이프사이클(Lifecycle)

### 생성 단계(Created)

- 컨테이너를 실행하기 위한 격리된 공간이 만들어지는 상태
- 내부에서 프로세스를 실제로 실행하지 않음 → 호스트 OS의 CPU와 메모리 모두 사용 안 함

  

**명령어**

- `docker create` : 이미지를 컨테이너로 만듦

  

### 실행 단계(Running)

- 컨테이너 메타데이터의 Cmd를 사용해서 컨테이너를 실행한 상태
- 컨테이너 내에서 정상적으로 프로세스가 실행 중이라는 것을 의미함
- 프로세스가 실제로 CPU와 메모리를 사용함

  

**명령어**

- `docker start` : 컨테이너를 실행함
- `docker restart` : 프로세스를 재시작함
    - 프로세스에 종료나 재시작 신호를 보내면 10초 뒤에 반영됨
- `docker run`  =  `docker create`  + `docker start` 

  

### 일시정지 단계(Paused)

- 컨테이너의 모든 프로세스가 일시정지된 상태
- 일시정지 → 현재의 상태를 모두 메모리에 저장해둠
- CPU는 사용하지 않고 메모리만 사용함

  

**명령어**

- `docker pause` : 프로세스를 일시정지함
- `docker unpause` : 프로세스를 일시정지한 시점부터 재시작함

  

### 종료 상태(Stopped)

- 컨테이너에서 실행 중인 프로세스가 완전히 중단된 상태
- CPU와 메모리 모두 사용하지 않음

  

**명령어**

- `docker stop` : 프로세스를 종료함
- `docker start` : 컨테이너를 실행함
    - 종료된 컨테이너를 다시 시작하면 컨테이너의 프로세스가 처음부터 다시 실행됨

  

### 삭제 상태(Deleted)

- 컨테이너는 모든 상태에서 `rm`  명령으로 삭제 가능
- 실행 중인 컨테이너를 삭제하려면 `-f`  옵션을 사용해야 함

  

### docker logs (컨테이너명)

컨테이너의 로그 조회

- `-f`  옵션으로 계속해서 출력을 확인할 수 있음

  

* * *

  

## 4\. 이미지 레지스트리
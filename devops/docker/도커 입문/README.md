# 도커 입문

# 1\. 환경 구성

**Winpty 설정**

Git Bash에서 Container Shell로 접근하려면 docker 앞에 winpty 명령어를 추가해야 함

```
echo "alias docker='winpty docker'" >> ~/.bashrc
```

  

**WSL(Windows Subsystem for Linux)**

Docker Desktop은 실제 윈도우 환경에서 컨테이너를 실행시키는 게 아닌 WSL이라는 소프트웨어를 통해 리눅스 가상환경에서 실행시킴

  

## 실행 중인 컨테이너를 모두 삭제하는 방법

```
docker rm -f $(docker ps -aq) # in MacOS
docker ps -aq | ForEach-Object {docker rm -f $_} # PowerShell in Windows
```

  

* * *

  

# 2\. 가상화 기술

## 2-1. 도커? 컨테이너?

도커: 컨테이너를 관리하기 위해 만들어진 소프트웨어

컨테이너: 큰 서버를 나누어서 효율적으로 사용하기 위한 가상화 기술

  

도커와 컨테이너를 이해하기 위해 서버와 가상화기술이 무엇이고 왜 사용해야 하는지 알아야 함

대표 가상화 기술: 하이퍼바이저 vs 컨테이너

  

## 2-2. 애플리케이션 서버

### 서버

(서버를 구성하는) 하드웨어 + 소프트웨어

- 일반적인 의미: 하드웨어에서 실행 중인 소프트웨어
- Serve: (무언가를) 제공해주다 → Server: 제공하는 주체
- 요청이 오면 처리하여 응답을 제공

  

**실제 기업에서 운영하는 서버**

- 파일서버: 파일 공유
- DB서버: 데이터 관리
- 웹서버: 정적 웹페이지 제공
- 웹 애플리케이션서버(WAS): 프로그래밍 언어로 개발된 백엔드 애플리케이션 실행

  

### 서버 운영 방식

1. 베어메탈 방식(Baremetal): 서버를 구입하고 그 위에 OS를 설치하고 여러 개의 소프트웨어를 실행

    - 기업에서 사용하기에는 비효율적인 방식

2. 하이퍼바이저 방식(Hypervisor)
3. 컨테이너 방식(Container)

  

엔터프라이즈 환경에서는 아주 많은 양의 서버를 운영해야 함

2, 3번이 가상화 기술을 활용한 서버 운영 방식

  

### 왜 개발자가 도커를 학습해야 하는가?

- 현대 IT 산업에서 인프라 운영은 **아주 높은 수준의 추상화** 기술을 제공
    - “아주 높은 수준의 추상화” → 다루기 더 쉬워짐
- 개발자와 운영자의 경계를 허무는 DevOps 문화 확산
- 소스 코드로 인프라를 운영하는 IAC 기술도 현업에서 많이 활용됨
- 도커를 활용하면 개발자가 인프라의 설정 영역까지 기술 스택 확장 가능
- MSA구조에서 개발자가 소스뿐만 아니라 애플리케이션 실행 환경까지 중요하게 고려해야 할 부분이 됨

###   

## 2-3. 가상화 기술

가상: 실제로 존재하지 않지만 실제로 존재하는 것처럼 느껴지는 것

가상 → 가상화 기술: 실제로 존재하는 컴퓨터가 아니지만 마치 존재하는 것처럼 만들어주는 기술

- 하나의 컴퓨터에서 여러 개의 컴퓨터를 실행시키는 기술
- 기술적 정의: 물리적인 컴퓨팅 환경 내부에서 논리적인 컴퓨팅 환경을 만들 수 있는 기술

  

**컴퓨터 여러 대를 사용하지 않고 복잡하게 가상화 기술을 사용하는 이유**

- 하드웨어의 사양은 높아지고 있는 반면, 소프트웨어의 크기는 상대적으로 낮아지고 있음
- 기업 입장에서 여러 면에서 훨씬 경제적임
    - 사양이 낮은 컴퓨터 하나를 사용하는 것보다 높은 성능 하나를 사용
    - 가격, 설치 공간, 설치 인력, 서버 운영, 전력 소모, 하드웨어 사이즈나 배선 등

  

### 하이퍼바이저

하이퍼바이저: 컴퓨터에 설치되는 프로그램

- OS에 하이퍼바이저를 실행해서 가상환경 관리

호스트 OS: 물리적인 서버에 실행되는 OS

- 물리적인 하드웨어와 직접 연결되어 있음
- 하이버바이저는 가상환경을 생성하고 호스트 OS 자원을 격리해서 새로운 OS 실행 → 게스트 OS

게스트 OS: 호스트 OS의 리소스를 나눈 논리적인 공간

- 가상머신이라고 부름
- 웹서버, WAS, DB 같은 서버 프로그램을 프로세스로 실행해서 운영

  

### 하이퍼바이저 서버 운영 방식

1. 서버에 호스트 OS 설치
2. 가상화 기술을 사용하기 위해 하이퍼바이저 설치
3. 가상머신을 만들어 게스트 OS 실행
4. 게스트 OS에서 실제 실행을 원하는 프로세스 운영

  

### 하이퍼바이저 역할

- 이 기종 커널 간 요청 전달
- 가상머신 리소스 할당량 관리

  

**하이퍼바이저가 리소스를 관리하는 방법**

호스트 OS가 커널에서 제공하는 시스템 콜을 통해 서버 하드웨어의 물리적인 리소스를 사용할 수 있음

게스트 OS가 이 리소스를 사용하려면?

1. 호스트 OS에서 여러 게스트 OS를 실행
2. 게스트 OS의 커널은 실제로 물리적인 하드웨어가 없기 때문에 호스트 OS의 커널로 리소스 사용 요청
3. 호스트 OS와 게스트 OS의 종류가 다르면 호스트 OS는 게스트 OS의 요청을 처리할 수 없음
4. 하이퍼바이저가 이 기종 커널 간 통역을 담당

  

## 2-4. 컨테이너 가상화 기술

“가볍고 빠르다”

###   

### 하이퍼바이저 vs 컨테이너 가상화

**컨테이너 가상화 기술의 시작, LXC**

- 컨테이너 가상화는 리눅스 커널이 제공하는 LXC(LinuX Containers)라는 자체 격리 기술에서 출발
- LXC 기술을 사용하면 하이퍼바이저를 사용하지 않고도 커널의 자체 기능만 사용해서 격리된 공간을 만들 수 있음

  

**LXC(LinuX Containers)**

커널의 네임스페이스와 CGroups(Control Groups) 라는 기능을 활용함

- 네임스페이스: 프로세스와 하드드라이브, 네트워크, 사용자, 호스트네임처럼 리소스를 나누는 기준의 역할
- CGroups: 프로세스가 사용하는 메모리와 CPU, 하드디스크, 네트워크 Bandwidth처럼 리소스의 사용량을 배분하는 기술

  

LXC 기술을 사용해서 만들어진 각각의 격리된 공간을 컨테이너라고 부름

  

### 컨테이너 가상화 방식은 가볍고 빠르다

컨테이너 가상화는 커널의 격리 기능을 활용하기 때문에 모든 컨테이너는 호스트 OS의 커널을 공유해서 사용

  

**오버헤드가 적다**

하이퍼바이저 방식: 각각의 시스템 콜들이 하이퍼바이저의 통역을 거침

- 요청이 거쳐가는 단계가 늘어남
- 즉, 오버헤드가 큼

컨테이너 가상화 방식: 호스트OS의 커널을 그대로 사용함

- 요청 중간단계가 없음
- 오버헤드가 상대적으로 적음
- 즉, 하드웨어 리소스 사용 요청이 더 효율적으로 이루어짐

  

**부팅 속도가 빠르다**

하이퍼바이저 방식

- 커널이 독립적으로 존재
- 즉, 커널을 실행함에 있어서 시간이 더 필요

컨테이너 가상화

- 하나의 호스트 OS 커널을 공유
- 커널을 실행하는 시간이 필요하지 않음
- 즉, 부팅 속도 빠름

**모던 애플리케이션의 중요 요구사항**  

- 적은 오버헤드
- 빠른 부팅

  

### 하지만, 항상 정답은 아니다

1. 하이퍼바이저 가상화는 커널을 독립적으로 가짐으로써 보안면에서는 더 뛰어남
2. 컨테이너 가상화는 호스트 OS의 커널을 공유하기 때문에 다른 종류의 OS는 실행할 수 없다는 점이 상대적인 단점임

  

## 2-5. 도커

커널이 자체적으로 제공하는 가상화 기술은 사용자가 직접 컨트롤하기 어려움

반면, 커널의 컨테이너 가상화 기술은 직접 컨트롤할 수 있어 도커를 통해 컨테이너를 만들고 운영할 수 있음

  

하이퍼바이저 방식에서 격리된 공간을 만드는 주체 → 하이퍼바이저라는 소프트웨어

컨테이너 가상화에서 실제 격리를 수행하는 주체 → 커널 그 자체

도커는 이 커널의 가상화 기술을 활용할 수 있게 도와주는 보조 도구임

  

도커? 2013년에 최초로 공개된 오픈소스 소프트웨어

컨테이너 가상화 기술을 사용하기 위한 도구

  

### 컨테이너 플랫폼

도커와 같은 컨테이너 가상화 도구

- 컨테이너 엔진: 사용자의 요청을 받아서 컨테이너 관리
- 컨테이너 런타임: 직접 커널과 통신하며 실제로 격리된 공간을 만드는 역할 수행
    - 도커는 runc라는 기본 컨테이너 런타임 사용
    - OCI에서 규정한 CRI(Container Runtime Interface) 표준을 구현했기 때문에 무조건 runc를 사용해야 하는 건 아님

  

컨테이너 가상화 기술을 사용할 때 어떤 컨테이너 플랫폼, 컨테이너 런타임을 사용할지는 자유롭게 선택 가능

이 중 도커는 가장 점유율이 높고 가장 빨리 출발했기 때문에 레퍼런스도 많고 문서도 잘 구성되어 있음

  

### 도커 아키텍처

- 클라이언트-서버 모델로 실행됨
    - 클라이언트: 사용자의 명령을 도커 데몬에 전달
    - 도커 데몬(Docker Daemon; 서버): 컨테이너를 관리하는 기능 제공

        - 데몬: 서버에서 지속적으로 실행해야 하는 소프트웨어

- 도커 데몬은 컨테이너 관리 기능을 클라이언트에 제공하기 위해 API 제공
    - 하지만 이 API의 응답을 사용자가 직접 핸들링하기에는 어려움이 있음
- Docker CLI: 도커 API 사용 편의성 제공
    - CLI는 사용자가 입력한 명령어를 API 요청 양식에 맞게 변환하여 전달
    - CLI는 전달받은 응답을 사용자가 보기 편한 테이블 형태로 만들어 화면에 표시

  

## 2-6. 컨테이너 실행

### docker version

Client, Server의 버전 및 상태 확인

  

### docker info

플러그인, 시스템 상세 정보 확인

  

### docker --help

메뉴얼 확인

  

### docker (Management Command) Commad

ex) docker (container) run → docker run

  

### docker run \[실행옵션\] 이미지명

컨테이너 실행

  

### docker rm \[컨테이너명/ID\]

컨테이너 삭제

  

* * *

  

# 3\. 이미지와 컨테이너